<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Street Network Viewer: Unified GPX Navigation</title>

<link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tmcw/togeojson@4.5.0/dist/togeojson.umd.js"></script>

<style>
  html, body { margin:0; padding:0; height:100%; background:#0b1020; font-family:system-ui, Arial, sans-serif; }
  #viewer-container { position:absolute; top:0; left:0; width:100%; height:50%; background:#0b1020; }
  #map { position:absolute; top:50%; left:0; width:100%; height:50%; }

  #canvas { width:100%; height:100%; touch-action:none; pointer-events:auto; user-select:none; }

  .controls {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    align-items: center;
    z-index: 20;
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.7);
    padding: 12px 16px;
    border-radius: 8px;
  }

  .nav-btn {
    padding: 10px 16px;
    font-size: 14px;
    font-weight: bold;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background: #4285F4;
    color: white;
    transition: all 0.2s;
  }

  .nav-btn:hover:not(:disabled) {
    background: #357ae8;
    transform: scale(1.05);
  }

  .nav-btn:disabled {
    background: #555;
    color: #999;
    cursor: not-allowed;
    opacity: 0.5;
  }

  .nav-btn.branch {
    background: #FF8C00;
    font-size: 12px;
    padding: 8px 12px;
  }

  .nav-btn.branch:hover:not(:disabled) {
    background: #ff7700;
  }

  .status-info {
    color: white;
    font-size: 12px;
    text-align: center;
    flex: 0 0 auto;
    min-width: 200px;
  }

  #viewer-info {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-size: 12px;
    background: rgba(0, 0, 0, 0.6);
    padding: 8px 12px;
    border-radius: 4px;
    z-index: 10;
  }

  #map-status {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: white;
    font-size: 12px;
    background: rgba(0, 0, 0, 0.6);
    padding: 8px 12px;
    border-radius: 4px;
    z-index: 10;
  }

  .view-cone-marker {
    background-color: #ff8400;
    border: 2px solid #ff6b6b;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    box-shadow: 0 0 10px rgba(255, 132, 0, 0.8);
  }

  #viewer-loading {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
    background: rgba(0, 0, 0, 0.8);
    padding: 20px 30px;
    border-radius: 10px;
    text-align: center;
    color: #fff;
  }

  .spinner {
    width: 36px;
    height: 36px;
    border: 4px solid rgba(255, 255, 255, 0.12);
    border-top-color: #22d3ee;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .dragging-pano .controls { pointer-events: none; }
</style>
</head>
<body>

<div id="viewer-container">
  <canvas id="canvas"></canvas>
  <div id="viewer-info">-</div>
  <div id="viewer-loading">
    <div class="spinner"></div>
    <div>Loading 360° image...</div>
  </div>
</div>

<div id="map">
  <div id="map-status">Loading…</div>
</div>

<div class="controls">
  <button class="nav-btn" id="backBtn">← Back</button>
  <div class="status-info" id="statusInfo">-</div>
  <button class="nav-btn" id="forwardBtn">Forward →</button>
  <div id="branchContainer" style="display: flex; gap: 6px;"></div>
</div>

<script>
/* =============================== */
/*            CONSTANTS            */
/* =============================== */
mapboxgl.accessToken = 'pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWN4ZWZvc3MwNjNjMnJwd3h6ZXdyOGJoIn0.ahgRYAxpOnGnnqOjQvJZTA';
const FRAMES_BASE = 'https://la-la.land/frames/';
const JUNCTION_RADIUS_M = 8; // Marbles within this distance from different tracks are junctions

/* =============================== */
/*            GLOBALS              */
/* =============================== */
let map;
let scene, camera, renderer, sphere, panoGroup;
let currentYaw = 0, currentPitch = 0, currentFov = 75;
let viewerInitialized = false;

// Unified marble network
let allMarbles = [];           // All marbles from all GPX files in one array
let marbleById = new Map();    // id -> marble object
let marbleNetwork = new Map(); // marbleId -> { neighbors: [{ id, distanceM, bearingDeg, trackId }] }

// Navigation state
let currentMarbleId = null;
let previousMarbleId = null;   // Where we came from (determines "back" direction)
let currentImages = [];
let currentImageIndex = -1;
let preloadedImages = {};

/* =============================== */
/*              INIT               */
/* =============================== */
window.addEventListener('DOMContentLoaded', initializeApp);

function initializeApp() {
  map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/outdoors-v12',
    center: [0, 0],
    zoom: 1,
    cooperativeGestures: false
  });

  map.on('load', async () => {
    initMapLayers();
    setupMapInteractions();

    try {
      await loadAndParseAllGPX();
      if (allMarbles.length > 0) {
        selectMarble(allMarbles[0].id);
        await loadImages();
      }
    } catch (e) {
      console.error('Init error:', e);
      setStatus('Error loading GPX files');
    }
  });

  initializeViewer();
}

function initMapLayers() {
  // Marbles layer
  map.addSource('marbles', {
    type: 'geojson',
    data: { type: 'FeatureCollection', features: [] }
  });

  map.addLayer({
    id: 'marbles-layer',
    type: 'circle',
    source: 'marbles',
    paint: {
      'circle-radius': [
        'case',
        ['==', ['get', 'isSelected'], true], 6,
        ['==', ['get', 'hasImage'], true], 2.5,
        3
      ],
      'circle-color': [
        'case',
        ['==', ['get', 'isSelected'], true], '#ff8400',
        ['==', ['get', 'hasImage'], true], '#34A853',
        '#8B4513'
      ],
      'circle-stroke-width': [
        'case',
        ['==', ['get', 'isSelected'], true], 2,
        1
      ],
      'circle-stroke-color': '#fff'
    }
  });

  map.addLayer({
    id: 'marbles-click-layer',
    type: 'circle',
    source: 'marbles',
    paint: {
      'circle-radius': 8,
      'circle-opacity': 0,
      'circle-stroke-width': 0
    }
  });

  // View cone
  map.addSource('view-cone', {
    type: 'geojson',
    data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[]] } }
  });

  map.addLayer({
    id: 'view-cone-fill',
    type: 'fill',
    source: 'view-cone',
    paint: { 'fill-color': '#ff8400', 'fill-opacity': 0.3 }
  });

  map.addLayer({
    id: 'view-cone-outline',
    type: 'line',
    source: 'view-cone',
    paint: { 'line-color': '#ff6b6b', 'line-width': 2 }
  });
}

function setupMapInteractions() {
  map.on('move', () => { if (currentMarbleId) updateViewCone(); });
  map.on('zoom', () => { if (currentMarbleId) updateViewCone(); });

  map.on('click', 'marbles-click-layer', (e) => {
    const marbleId = e.features[0].properties.id;
    selectMarble(marbleId);
    showMarbleImage(marbleId);
  });
}

/* =============================== */
/*          GPX LOADING            */
/* =============================== */
async function loadAndParseAllGPX() {
  try {
    const res = await fetch(FRAMES_BASE + 'index.json', { cache: 'no-store' });
    if (!res.ok) {
      setStatus('No predefined tracks found');
      return;
    }

    const manifest = await res.json();
    let gpxFiles = manifest.gpxFiles || manifest.files?.filter(f => f.toLowerCase().endsWith('.gpx')) || [];

    if (!gpxFiles.length) {
      setStatus('No GPX files in manifest');
      return;
    }

    // Load all GPX files into unified marble list
    for (const gpxFile of gpxFiles) {
      try {
        await loadSingleGPX(gpxFile);
      } catch (e) {
        console.error('Failed to load GPX:', gpxFile, e);
      }
    }

    if (allMarbles.length === 0) {
      setStatus('No marbles loaded from GPX files');
      return;
    }

    // Build the unified network graph
    buildMarbleNetwork();
    updateMarbleDisplay();
    setStatus(`Loaded ${allMarbles.length} marbles from ${gpxFiles.length} GPX files`);

  } catch (e) {
    console.error('Error loading GPX manifest:', e);
    setStatus('Error loading manifest');
  }
}

async function loadSingleGPX(filename) {
  const fullPath = filename.startsWith(FRAMES_BASE) ? filename : FRAMES_BASE + filename;
  const response = await fetch(fullPath);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);

  const gpxContent = await response.text();
  const parser = new DOMParser();
  const gpxDoc = parser.parseFromString(gpxContent, 'text/xml');

  const baseName = filename.split('/').pop().replace('.gpx', '');
  const trkpts = gpxDoc.querySelectorAll('trkpt');

  if (trkpts.length === 0) return;

  // Parse waypoints as marbles
  const waypoints = gpxDoc.querySelectorAll('wpt');
  waypoints.forEach((wpt, idx) => {
    const lat = parseFloat(wpt.getAttribute('lat'));
    const lon = parseFloat(wpt.getAttribute('lon'));
    const nameEl = wpt.querySelector('name');
    const descEl = wpt.querySelector('desc');

    const name = nameEl ? nameEl.textContent : `Waypoint_${idx + 1}`;
    const desc = descEl ? descEl.textContent : '';

    const marble = {
      id: `${baseName}-${idx}`,
      trackId: baseName,
      position: [lon, lat],
      name,
      description: desc,
      assignedImage: extractImageIndex(name, desc),
      index: allMarbles.length
    };

    allMarbles.push(marble);
    marbleById.set(marble.id, marble);
  });
}

function extractImageIndex(name, description) {
  const text = (name + ' ' + description).toLowerCase();
  const m1 = text.match(/image[^\d]*(\d+)/);
  if (m1) return parseInt(m1[1]) - 1;
  const m2 = text.match(/photo[^\d]*(\d+)/);
  if (m2) return parseInt(m2[1]) - 1;
  const m3 = name?.match(/(\d+)$/);
  if (m3) return parseInt(m3[1]) - 1;
  return null;
}

/* =============================== */
/*      NETWORK BUILDING           */
/* =============================== */
function buildMarbleNetwork() {
  // Initialize network map
  marbleNetwork.clear();
  allMarbles.forEach(m => {
    marbleNetwork.set(m.id, []);
  });

  // 1. Add sequential connections within same track
  const trackGroups = new Map();
  allMarbles.forEach(m => {
    if (!trackGroups.has(m.trackId)) trackGroups.set(m.trackId, []);
    trackGroups.get(m.trackId).push(m);
  });

  trackGroups.forEach((marbles, trackId) => {
    // Sort by index within track (they should already be sorted, but ensure it)
    const sortedByName = marbles.sort((a, b) => {
      const numA = parseInt(a.name.match(/\d+/)?.[0] || 0);
      const numB = parseInt(b.name.match(/\d+/)?.[0] || 0);
      return numA - numB;
    });

    // Connect sequential marbles
    for (let i = 0; i < sortedByName.length - 1; i++) {
      const a = sortedByName[i];
      const b = sortedByName[i + 1];
      const dist = calculateDistance(a.position, b.position);
      const bearing = calculateBearing(a.position, b.position);

      marbleNetwork.get(a.id).push({
        toId: b.id,
        distanceM: dist,
        bearingDeg: bearing,
        type: 'sequential'
      });

      marbleNetwork.get(b.id).push({
        toId: a.id,
        distanceM: dist,
        bearingDeg: (bearing + 180) % 360,
        type: 'sequential'
      });
    }
  });

  // 2. Add junction connections across tracks (nearby marbles)
  for (let i = 0; i < allMarbles.length; i++) {
    for (let j = i + 1; j < allMarbles.length; j++) {
      const a = allMarbles[i];
      const b = allMarbles[j];

      if (a.trackId === b.trackId) continue; // Skip if same track

      const dist = calculateDistance(a.position, b.position);
      if (dist > JUNCTION_RADIUS_M) continue;

      const bearing = calculateBearing(a.position, b.position);

      // Check if this edge already exists (avoid duplicates)
      const existsFromA = marbleNetwork.get(a.id).some(e => e.toId === b.id);
      const existsFromB = marbleNetwork.get(b.id).some(e => e.toId === a.id);

      if (!existsFromA) {
        marbleNetwork.get(a.id).push({
          toId: b.id,
          distanceM: dist,
          bearingDeg: bearing,
          type: 'junction'
        });
      }

      if (!existsFromB) {
        marbleNetwork.get(b.id).push({
          toId: a.id,
          distanceM: dist,
          bearingDeg: (bearing + 180) % 360,
          type: 'junction'
        });
      }
    }
  }

  // 3. Deduplicate: keep shortest edge to each target
  marbleNetwork.forEach((edges, fromId) => {
    const byTarget = new Map();
    edges.forEach(e => {
      const existing = byTarget.get(e.toId);
      if (!existing || e.distanceM < existing.distanceM) {
        byTarget.set(e.toId, e);
      }
    });
    marbleNetwork.set(fromId, Array.from(byTarget.values()));
  });
}

/* =============================== */
/*        MARBLE SELECTION         */
/* =============================== */
function selectMarble(marbleId) {
  if (!marbleById.has(marbleId)) return;

  // Update navigation state
  previousMarbleId = currentMarbleId;
  currentMarbleId = marbleId;

  updateMarbleDisplay();
  updateControlsState();
  updateViewCone();

  showMarbleImage(marbleId);
}

function getNavigationOptions() {
  if (!currentMarbleId) return { back: null, forward: null, branches: [] };

  const neighbors = marbleNetwork.get(currentMarbleId) || [];

  // Back option: the marble we came from (previousMarbleId)
  const backOption = previousMarbleId && neighbors.find(n => n.toId === previousMarbleId)
    ? { id: previousMarbleId }
    : null;

  // Forward options: all neighbors except the one we came from
  const forwardOptions = neighbors
    .filter(n => n.toId !== previousMarbleId)
    .sort((a, b) => {
      // Sort by distance (prefer closer)
      return a.distanceM - b.distanceM;
    });

  if (forwardOptions.length === 0) {
    // Dead end
    return { back: backOption, forward: null, branches: [] };
  } else if (forwardOptions.length === 1) {
    // Linear path
    return {
      back: backOption,
      forward: { id: forwardOptions[0].toId },
      branches: []
    };
  } else {
    // Junction: first is "straight", rest are branches
    return {
      back: backOption,
      forward: { id: forwardOptions[0].toId },
      branches: forwardOptions.slice(1).map(opt => ({ id: opt.toId }))
    };
  }
}

function updateControlsState() {
  const opts = getNavigationOptions();
  const backBtn = document.getElementById('backBtn');
  const forwardBtn = document.getElementById('forwardBtn');
  const branchContainer = document.getElementById('branchContainer');
  const statusInfo = document.getElementById('statusInfo');

  // Update back button
  backBtn.disabled = !opts.back;
  backBtn.onclick = () => {
    if (opts.back) navigate(opts.back.id);
  };

  // Update forward button
  forwardBtn.disabled = !opts.forward;
  forwardBtn.onclick = () => {
    if (opts.forward) navigate(opts.forward.id);
  };

  // Update branch buttons
  branchContainer.innerHTML = '';
  opts.branches.forEach((branch, idx) => {
    const btn = document.createElement('button');
    btn.className = 'nav-btn branch';
    btn.textContent = `Branch ${idx + 1}`;
    btn.onclick = () => navigate(branch.id);
    branchContainer.appendChild(btn);
  });

  // Update status info
  const marble = marbleById.get(currentMarbleId);
  const track = marble.trackId;
  const totalNeighbors = (marbleNetwork.get(currentMarbleId) || []).length;
  statusInfo.innerHTML = `
    <strong>${track}</strong><br>
    ${marble.name}<br>
    ${totalNeighbors > 1 ? `Junction: ${totalNeighbors} connections` : totalNeighbors === 0 ? 'Dead end' : 'Linear path'}
  `;
}

function navigate(toMarbleId) {
  previousMarbleId = currentMarbleId;
  currentMarbleId = toMarbleId;

  updateMarbleDisplay();
  updateControlsState();
  updateViewCone();

  // Optionally animate camera to face the new marble
  const currentMarble = marbleById.get(previousMarbleId);
  const nextMarble = marbleById.get(toMarbleId);
  if (currentMarble && nextMarble) {
    const bearing = calculateBearing(currentMarble.position, nextMarble.position);
    animateCameraToHeading(bearing);
  }

  showMarbleImage(toMarbleId);

  // Fly map to new marble
  map.flyTo({
    center: nextMarble.position,
    zoom: map.getZoom(),
    duration: 400
  });
}

/* =============================== */
/*      MARBLE DISPLAY             */
/* =============================== */
function updateMarbleDisplay() {
  const features = allMarbles.map(m => ({
    type: 'Feature',
    geometry: { type: 'Point', coordinates: m.position },
    properties: {
      id: m.id,
      trackId: m.trackId,
      isSelected: m.id === currentMarbleId,
      hasImage: m.assignedImage !== null
    }
  }));

  const source = map.getSource('marbles');
  if (source) {
    source.setData({ type: 'FeatureCollection', features });
  }
}

/* =============================== */
/*        IMAGE MANAGEMENT         */
/* =============================== */
async function loadImages() {
  try {
    const res = await fetch(FRAMES_BASE + 'index.json', { cache: 'no-store' });
    if (!res.ok) return;

    const manifest = await res.json();
    const fileList = Array.isArray(manifest) ? manifest : manifest.files || [];
    const imageFiles = fileList.filter(f => /\.(jpe?g|png)$/i.test(f));

    currentImages = imageFiles.map((url, idx) => ({
      url: FRAMES_BASE + url.split('/').pop(),
      index: idx
    }));
  } catch (e) {
    console.error('Error loading images:', e);
  }
}

function showMarbleImage(marbleId) {
  const marble = marbleById.get(marbleId);
  if (!marble || marble.assignedImage === null) {
    document.getElementById('viewer-info').textContent = `${marble?.name} - No image`;
    return;
  }

  const imageIdx = marble.assignedImage;
  if (imageIdx < 0 || imageIdx >= currentImages.length) {
    document.getElementById('viewer-info').textContent = `Image ${imageIdx} not found`;
    return;
  }

  currentImageIndex = imageIdx;
  const image = currentImages[imageIdx];
  showImageInViewer(image.url);
}

function showImageInViewer(imageUrl) {
  if (!viewerInitialized) initThreeJSViewer();

  showViewerLoading();

  if (preloadedImages[imageUrl]) {
    hideViewerLoading();
    applyImageToSphere(preloadedImages[imageUrl]);
    return;
  }

  const img = new Image();
  img.crossOrigin = 'Anonymous';
  img.onload = () => {
    preloadedImages[imageUrl] = img;
    hideViewerLoading();
    applyImageToSphere(img);
  };
  img.onerror = () => {
    console.error('Failed to load image:', imageUrl);
    hideViewerLoading();
    setStatus('Failed to load 360 image');
  };
  img.src = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
}

/* =============================== */
/*      THREE.JS VIEWER           */
/* =============================== */
function initThreeJSViewer() {
  if (viewerInitialized) return;

  scene = new THREE.Scene();
  panoGroup = new THREE.Group();
  scene.add(panoGroup);

  const canvas = document.getElementById('canvas');
  camera = new THREE.PerspectiveCamera(currentFov, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(0, 0, 0.1);

  renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    alpha: false,
    powerPreference: 'high-performance'
  });

  const dpr = Math.min(window.devicePixelRatio || 4, 4);
  renderer.setPixelRatio(dpr);
  renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

  setupViewerEventListeners();
  animateViewer();
  viewerInitialized = true;
}

function animateViewer() {
  requestAnimationFrame(animateViewer);
  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

function applyImageToSphere(img) {
  if (sphere) {
    panoGroup.remove(sphere);
    sphere.geometry?.dispose();
    sphere.material?.map?.dispose();
    sphere.material?.dispose();
  }

  const geometry = new THREE.SphereGeometry(100, 60, 40);
  geometry.scale(-1, 1, 1);
  geometry.rotateY(Math.PI);

  const texture = new THREE.Texture(img);
  texture.needsUpdate = true;

  const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
  sphere = new THREE.Mesh(geometry, material);

  sphere.rotation.y = currentYaw;
  sphere.rotation.x = currentPitch;

  panoGroup.add(sphere);
}

function setupViewerEventListeners() {
  const canvas = document.getElementById('canvas');
  let isDragging = false;
  let lastX = 0, lastY = 0;
  let touchStartX = 0, touchStartY = 0;
  let initialDistance = 0;

  // Mouse controls
  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
    canvas.style.cursor = 'grabbing';
    document.body.classList.add('dragging-pano');
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging || !sphere) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;

    sphere.rotation.y -= dx * 0.01;
    sphere.rotation.x -= dy * 0.01;

    currentYaw = sphere.rotation.y;
    currentPitch = sphere.rotation.x;

    lastX = e.clientX;
    lastY = e.clientY;

    updateViewCone();
  });

  canvas.addEventListener('mouseup', () => {
    isDragging = false;
    canvas.style.cursor = 'grab';
    document.body.classList.remove('dragging-pano');
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomSpeed = e.deltaMode === 0 ? 2 : 60;
    const delta = e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
    currentFov = Math.max(30, Math.min(120, currentFov + delta));
    camera.fov = currentFov;
    camera.updateProjectionMatrix();
    updateViewCone();
  });

  // Touch controls
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      initialDistance = Math.sqrt(dx * dx + dy * dy);
    }
  });

  canvas.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1 && sphere) {
      const dx = e.touches[0].clientX - touchStartX;
      const dy = e.touches[0].clientY - touchStartY;

      sphere.rotation.y -= dx * 0.01;
      sphere.rotation.x -= dy * 0.01;

      currentYaw = sphere.rotation.y;
      currentPitch = sphere.rotation.x;

      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;

      updateViewCone();
    } else if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const currentDistance = Math.sqrt(dx * dx + dy * dy);

      if (initialDistance > 0) {
        const zoomChange = initialDistance - currentDistance;
        currentFov = Math.max(30, Math.min(120, currentFov + zoomChange * 0.1));
        camera.fov = currentFov;
        camera.updateProjectionMatrix();
        initialDistance = currentDistance;
        updateViewCone();
      }
    }
  });

  canvas.addEventListener('touchend', () => {
    touchStartX = 0;
    touchStartY = 0;
    initialDistance = 0;
  });
}

function animateCameraToHeading(targetBearingDeg) {
  // Smoothly rotate sphere to face the target bearing
  const targetYaw = (targetBearingDeg - 90) * Math.PI / 180;
  const startYaw = currentYaw;
  const startTime = Date.now();
  const duration = 600;

  const animateHeading = () => {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);

    // Interpolate yaw
    currentYaw = startYaw + (targetYaw - startYaw) * progress;
    if (sphere) sphere.rotation.y = currentYaw;

    if (progress < 1) {
      requestAnimationFrame(animateHeading);
    }
  };

  animateHeading();
}

/* =============================== */
/*          VIEW CONE              */
/* =============================== */
function updateViewCone() {
  if (!map || !currentMarbleId) return;

  const marble = marbleById.get(currentMarbleId);
  if (!marble) return;

  const yawDeg = THREE.MathUtils.radToDeg(currentYaw);
  const hFov = getHorizontalFov();
  const radius = 15;

  const ring = makeViewConeRing(
    marble.position[1],
    marble.position[0],
    yawDeg,
    hFov,
    radius,
    24
  );

  const source = map.getSource('view-cone');
  if (source) {
    source.setData({
      type: 'Feature',
      geometry: { type: 'Polygon', coordinates: [ring] }
    });
  }
}

function getHorizontalFov() {
  const canvas = document.getElementById('canvas');
  const aspect = (camera && camera.aspect) || (canvas && canvas.clientHeight ? canvas.clientWidth / canvas.clientHeight : 16 / 9);
  const vRad = THREE.MathUtils.degToRad(currentFov);
  const hRad = 2 * Math.atan(Math.tan(vRad / 2) * aspect);
  return THREE.MathUtils.radToDeg(hRad);
}

function makeViewConeRing(lat, lon, headingDeg, fovDeg, radiusMeters = 15, steps = 24) {
  const half = Math.max(0, Math.min(89, fovDeg / 2));
  const start = headingDeg - half;
  const end = headingDeg + half;
  const ring = [[lon, lat]];

  for (let s = 0; s <= steps; s++) {
    const t = s / steps;
    const brg = start + (end - start) * t;
    ring.push(destFromBearing(lat, lon, brg, radiusMeters));
  }

  ring.push([lon, lat]);
  return ring;
}

function destFromBearing(lat, lon, bearingDeg, distMeters) {
  const R = 6378137;
  const brng = bearingDeg * Math.PI / 180;
  const φ1 = lat * Math.PI / 180;
  const λ1 = lon * Math.PI / 180;

  const φ2 = Math.asin(
    Math.sin(φ1) * Math.cos(distMeters / R) +
    Math.cos(φ1) * Math.sin(distMeters / R) * Math.cos(brng)
  );

  const λ2 = λ1 + Math.atan2(
    Math.sin(brng) * Math.sin(distMeters / R) * Math.cos(φ1),
    Math.cos(distMeters / R) - Math.sin(φ1) * Math.sin(φ2)
  );

  return [λ2 * 180 / Math.PI, φ2 * 180 / Math.PI];
}

/* =============================== */
/*          MATH HELPERS           */
/* =============================== */
function calculateDistance(a, b) {
  const R = 6371000; // Earth radius in meters
  const dLat = (b[1] - a[1]) * Math.PI / 180;
  const dLon = (b[0] - a[0]) * Math.PI / 180;
  const lat1 = a[1] * Math.PI / 180;
  const lat2 = b[1] * Math.PI / 180;

  const h = Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;

  return 2 * R * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
}

function calculateBearing(a, b) {
  const toRad = (d) => d * Math.PI / 180;
  const toDeg = (r) => r * 180 / Math.PI;

  const φ1 = toRad(a[1]);
  const φ2 = toRad(b[1]);
  const λ1 = toRad(a[0]);
  const λ2 = toRad(b[0]);

  const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
  const x = Math.cos(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1) - Math.sin(φ1) * Math.sin(φ2);

  return (toDeg(Math.atan2(y, x)) + 360) % 360;
}

/* =============================== */
/*          UI HELPERS             */
/* =============================== */
function showViewerLoading() {
  const el = document.getElementById('viewer-loading');
  if (el) el.style.display = 'block';
}

function hideViewerLoading() {
  const el = document.getElementById('viewer-loading');
  if (el) el.style.display = 'none';
}

function setStatus(msg) {
  const el = document.getElementById('map-status');
  if (el) el.textContent = msg;
}

</script>
</body>
</html>
