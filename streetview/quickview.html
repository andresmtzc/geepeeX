<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapbox Viewer — Path Smoothing</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css">
  <script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Instrument+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: 'Instrument Sans', sans-serif; overflow: hidden; background: #000; }
    #main-container { display: flex; flex-direction: column; height: 100vh; }

    #viewer-section { height: 50%; background: #111; position: relative; display: flex; flex-direction: column; border-bottom: 2px solid #333; }
    #viewer-header { padding: 8px 15px; background: #222; color: white; display: flex; justify-content: space-between; align-items: center; font-size: 13px; z-index: 10; }
    #viewer-body { flex-grow: 1; position: relative; background: #000; }
    #panorama { width: 100%; height: 100%; }

    #map-section { height: 50%; position: relative; display: flex; }
    #left-panel {
      width: 280px; background: linear-gradient(180deg, #1a1a1a 0%, #0f0f0f 100%);
      border-right: 1px solid #333; overflow-y: auto; z-index: 50;
      box-shadow: 4px 0 12px rgba(0,0,0,0.5);
    }
    #map { flex: 1; height: 100%; }

    .panel-section {
      border-bottom: 1px solid #2a2a2a;
      padding: 16px;
    }
    .panel-section:last-child { border-bottom: none; }
    
    .section-title {
      font-size: 10px; font-weight: 700; letter-spacing: 1.2px;
      color: #666; text-transform: uppercase; margin-bottom: 12px;
      font-family: 'JetBrains Mono', monospace;
    }

    .checkbox-row {
      display: flex; align-items: center; gap: 10px;
      padding: 8px 0; cursor: pointer;
      transition: background 0.15s;
      border-radius: 4px; margin: 0 -6px; padding-left: 6px;
    }
    .checkbox-row:hover { background: rgba(255,255,255,0.03); }
    
    .checkbox-row input[type="checkbox"] {
      width: 18px; height: 18px; cursor: pointer;
      accent-color: #1fb6ff;
    }
    
    .checkbox-row label {
      color: #ccc; font-size: 13px; cursor: pointer;
      user-select: none; flex: 1;
    }

    .slider-container {
      margin: 12px 0;
    }
    .slider-label {
      display: flex; justify-content: space-between;
      font-size: 11px; color: #999; margin-bottom: 6px;
    }
    .slider-label .value {
      color: #1fb6ff; font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
    }
    
    input[type="range"] {
      width: 100%; height: 6px;
      background: #333; border-radius: 3px;
      outline: none; cursor: pointer;
      -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px;
      background: #1fb6ff; border-radius: 50%;
      cursor: pointer; box-shadow: 0 2px 6px rgba(31,182,255,0.4);
    }
    input[type="range"]::-moz-range-thumb {
      width: 16px; height: 16px; background: #1fb6ff;
      border-radius: 50%; cursor: pointer; border: none;
      box-shadow: 0 2px 6px rgba(31,182,255,0.4);
    }

    .btn {
      width: 100%; padding: 10px 14px;
      background: linear-gradient(135deg, #1fb6ff 0%, #0d8fd9 100%);
      border: none; border-radius: 6px;
      color: white; font-weight: 600; font-size: 12px;
      cursor: pointer; margin: 8px 0;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(31,182,255,0.2);
      font-family: 'Instrument Sans', sans-serif;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(31,182,255,0.4);
    }
    .btn:active { transform: translateY(0); }
    
    .btn-secondary {
      background: linear-gradient(135deg, #444 0%, #333 100%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .btn-secondary:hover {
      background: linear-gradient(135deg, #555 0%, #444 100%);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
      box-shadow: 0 2px 8px rgba(255,68,68,0.2);
    }
    .btn-danger:hover {
      box-shadow: 0 4px 12px rgba(255,68,68,0.4);
    }

    .btn:disabled {
      background: #2a2a2a; color: #666;
      cursor: not-allowed; transform: none;
      box-shadow: none;
    }

    .mode-indicator {
      display: inline-block;
      padding: 4px 10px; border-radius: 4px;
      font-size: 10px; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.8px;
      font-family: 'JetBrains Mono', monospace;
    }
    .mode-indicator.active {
      background: #1fb6ff; color: #000;
      animation: pulse 2s ease-in-out infinite;
    }
    .mode-indicator.inactive {
      background: #333; color: #666;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Compass Rose */
    #compass-container {
      position: absolute; bottom: 20px; right: 20px;
      width: 85px; height: 85px; z-index: 100;
      background: rgba(0,0,0,0.6); border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
      display: flex; align-items: center; justify-content: center;
      backdrop-filter: blur(4px);
    }
    #compass-rose { position: relative; width: 100%; height: 100%; transition: transform 0.05s linear; }
    .compass-btn {
      position: absolute; width: 26px; height: 26px;
      display: flex; align-items: center; justify-content: center;
      color: white; font-weight: bold; cursor: pointer;
      background: rgba(31, 182, 255, 0.2); border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);
    }
    .compass-btn:hover { background: #1fb6ff; color: black; }
    .nav-forward { top: 4px; left: 50%; transform: translateX(-50%); }
    .nav-backward { bottom: 4px; left: 50%; transform: translateX(-50%); }
    #north-pointer {
      position: absolute; top: 0; left: 50%; transform: translateX(-50%);
      width: 0; height: 0; border-left: 7px solid transparent; border-right: 7px solid transparent; border-bottom: 14px solid #ff4444;
    }

    #ui-overlay { 
      position: absolute; bottom: 10px; left: 10px; right: 10px;
      background: rgba(0,0,0,0.85); padding: 12px; border-radius: 8px;
      display: flex; gap: 20px; align-items: center; color: white; z-index: 20;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .custom-marker { 
      width: 12px; height: 12px; border-radius: 50%; 
      border: 2px solid white; cursor: pointer; transition: 0.2s; 
    }
    .custom-marker.active { 
      background-color: #ffeb3b !important; transform: scale(1.6); 
      border-color: #000; box-shadow: 0 0 10px #ffeb3b; z-index: 10; 
    }
    .custom-marker.projected {
      background-color: #26a269 !important;
      border-color: #fff;
    }
    
    button { background:#1fb6ff; border:none; padding:6px 14px; border-radius:4px; font-weight:bold; cursor:pointer; font-size: 12px; }
    
    .empty-state { 
      height: 100%; display: flex; flex-direction: column; 
      align-items: center; justify-content: center; 
      color: #555; font-style: italic; 
    }

    /* Control Point Markers */
    .control-point-marker {
      width: 14px; height: 14px;
      background: #ffeb3b;
      border: 2px solid #000;
      transform: rotate(45deg);
      cursor: move;
      box-shadow: 0 0 8px rgba(255,235,59,0.6);
      transition: all 0.2s;
    }
    .control-point-marker:hover {
      width: 18px; height: 18px;
      box-shadow: 0 0 12px rgba(255,235,59,0.9);
    }
  </style>
</head>
<body>

<div id="main-container">
  <div id="viewer-section">
    <div id="viewer-header">
      <div><b id="viewer-title">Street View</b> <span id="viewer-meta" style="margin-left:10px; opacity:0.7;"></span></div>
      <div id="preloading-indicator" style="font-size:10px; color:#888;">Cache Ready</div>
    </div>
    
    <div id="viewer-body">
      <div id="panorama"></div>
      
      <div id="compass-container">
        <div id="compass-rose">
          <div id="north-pointer"></div>
          <div class="compass-btn nav-forward" onclick="navigate(1)">▲</div>
          <div class="compass-btn nav-backward" onclick="navigate(-1)">▼</div>
        </div>
      </div>

      <div id="empty-msg" class="empty-state">
        <p>Connecting to GitHub assets...</p>
      </div>
    </div>
  </div>

  <div id="map-section">
    <div id="left-panel">
      <!-- VIEW CONTROLS -->
      <div class="panel-section">
        <div class="section-title">View Controls</div>
        <div class="checkbox-row">
          <input type="checkbox" id="showBlueDots" checked>
          <label for="showBlueDots">Show Blue Dots</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="showBlueTrack" checked>
          <label for="showBlueTrack">Show Blue Track</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="showRedTrack">
          <label for="showRedTrack">Show Red Track</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="showControlPoints" checked>
          <label for="showControlPoints">Show Diamond CPs</label>
        </div>
      </div>

      <!-- SMOOTHING -->
      <div class="panel-section">
        <div class="section-title">Smoothing</div>
        <button class="btn" id="generateRedBtn">Generate Red Track</button>
        <div style="margin-top: 12px;">
          <div class="checkbox-row">
            <input type="checkbox" id="addCPMode">
            <label for="addCPMode">Add CP Mode</label>
          </div>
          <div style="font-size: 10px; color: #666; margin-top: 4px; padding-left: 28px;">
            Click on red line to insert control points
          </div>
        </div>
        <div style="margin-top: 12px;">
          <div class="checkbox-row">
            <input type="checkbox" id="removeCPMode">
            <label for="removeCPMode">Remove CP Mode</label>
          </div>
          <div style="font-size: 10px; color: #666; margin-top: 4px; padding-left: 28px;">
            Click on diamonds to remove them
          </div>
        </div>
      </div>

      <!-- EDITING -->
      <div class="panel-section">
        <div class="section-title">Editing</div>
        <button class="btn" id="projectPointsBtn" disabled>Project Points to Red</button>
        <div style="margin: 12px 0;">
          <div class="checkbox-row">
            <input type="checkbox" id="dragMode">
            <label for="dragMode">Drag Mode</label>
          </div>
          <div style="font-size: 10px; color: #666; margin-top: 4px; padding-left: 28px;">
            Move dots along red curve
          </div>
        </div>
        <button class="btn btn-danger" id="exportBtn" disabled>Export JSON</button>
      </div>

      <!-- STATUS -->
      <div class="panel-section">
        <div class="section-title">Status</div>
        <div style="font-size: 11px; color: #999; line-height: 1.6;">
          <div>Blue Points: <span id="blueCount" style="color: #1fb6ff; font-weight: 600;">0</span></div>
          <div>Control Points: <span id="cpCount" style="color: #ffeb3b; font-weight: 600;">0</span></div>
          <div>Projected: <span id="projectedCount" style="color: #26a269; font-weight: 600;">0</span></div>
        </div>
      </div>
    </div>

    <div id="map"></div>
    
    <div id="ui-overlay">
      <div style="display:flex; flex-direction:column; gap:4px;">
        <label style="font-size:10px; font-weight:bold; color:#1fb6ff;">MANUAL JSON</label>
        <input id="jsonInput" type="file" accept=".json" style="font-size:11px;"/>
      </div>
      <div style="display:flex; flex-direction:column; gap:4px;">
        <label style="font-size:10px; font-weight:bold; color:#1fb6ff;">MANUAL IMAGES</label>
        <input id="imagesInput" type="file" webkitdirectory directory multiple style="font-size:11px;"/>
      </div>
      <div style="margin-left:auto; text-align:right;">
        <button id="fitBtn">Recenter</button>
      </div>
    </div>
  </div>
</div>

<script>
mapboxgl.accessToken = "pk.eyJ1IjoiYW5kcmVzbXR6YyIsImEiOiJjbWl5eWQ0a2gwbDRlM2RweTN6ZXY1MmRsIn0.RDhU90VJPV_Bcjt1tab-MQ";

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/satellite-streets-v12',
  center: [-100.3483, 25.6752],
  zoom: 15
});

let points = [];
let markers = {};
let imagesByIndex = {}; 
let currentIdx = -1;
let panoViewer = null;
let preloadedUrls = new Set();

// Smoothing state
let controlPoints = [];
let controlPointMarkers = [];
let redTrackLine = null;
let projectedPoints = [];
let addCPModeActive = false;
let removeCPModeActive = false;
let dragModeActive = false;
let draggedMarkerIndex = null;

const GITHUB_BASE = "https://andresmtzc.github.io/geepeeX/streetview/";
const DEFAULT_JSON = GITHUB_BASE + "trip_1769904967799.json";

/* ========================
   CATMULL-ROM SPLINE
======================== */
function catmullRom(p0, p1, p2, p3, t) {
  const t2 = t * t;
  const t3 = t2 * t;
  
  return [
    0.5 * ((2 * p1[0]) +
      (-p0[0] + p2[0]) * t +
      (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 +
      (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3),
    0.5 * ((2 * p1[1]) +
      (-p0[1] + p2[1]) * t +
      (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 +
      (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3)
  ];
}

function generateCatmullRomCurve(controlPts, segmentsPerSection = 20) {
  if (controlPts.length < 2) return controlPts;
  
  const curve = [];
  const n = controlPts.length;
  
  for (let i = 0; i < n - 1; i++) {
    const p0 = i === 0 ? controlPts[i] : controlPts[i - 1];
    const p1 = controlPts[i];
    const p2 = controlPts[i + 1];
    const p3 = i === n - 2 ? controlPts[i + 1] : controlPts[i + 2];
    
    for (let j = 0; j < segmentsPerSection; j++) {
      const t = j / segmentsPerSection;
      curve.push(catmullRom(p0, p1, p2, p3, t));
    }
  }
  curve.push(controlPts[n - 1]);
  
  return curve;
}

/* ========================
   PRELOADING
======================== */
function preloadNeighbors(index) {
  const range = 3;
  for (let i = -range; i <= range; i++) {
    if (i === 0) continue;
    let neighborIdx = (index + i + points.length) % points.length;
    let p = points[neighborIdx];
    let url = imagesByIndex[p.index];
    
    if (url && !preloadedUrls.has(url)) {
      const img = new Image();
      img.src = url;
      preloadedUrls.add(url);
    }
  }
}

/* ========================
   DATA LOADING
======================== */
async function loadDefaultData() {
  try {
    const response = await fetch(DEFAULT_JSON);
    const data = await response.json();
    data.points.forEach(p => {
      imagesByIndex[p.index] = `${GITHUB_BASE}img${p.index}.jpg`;
    });
    processPoints(data.points);
  } catch (err) {
    document.getElementById('empty-msg').innerHTML = "<p>Fetch failed. Load local files.</p>";
  }
}

function processPoints(rawPoints) {
  points = rawPoints.sort((a,b) => a.index - b.index);
  Object.values(markers).forEach(m => m.remove());
  markers = {};
  
  // Add blue track
  if (map.getLayer('track')) map.removeLayer('track');
  if (map.getSource('track')) map.removeSource('track');
  map.addSource('track', { 
    type:'geojson', 
    data:{ 
      type:'Feature', 
      geometry:{ 
        type:'LineString', 
        coordinates: points.map(p=>[p.lon,p.lat]) 
      }
    } 
  });
  map.addLayer({ 
    id:'track', 
    type:'line', 
    source:'track', 
    paint:{ 
      'line-color':'#1fb6ff',
      'line-width':3, 
      'line-opacity': 0.7 
    }
  });

  // Add markers
  points.forEach(p => {
    const el = document.createElement('div');
    el.className = 'custom-marker';
    el.onclick = () => openViewer(p.index);
    el.dataset.index = p.index;
    markers[p.index] = new mapboxgl.Marker({ element: el, draggable: false })
      .setLngLat([p.lon, p.lat])
      .addTo(map);
  });

  updateMarkerColors();
  updateStatus();
  fitToTrack();
  if(points.length > 0) openViewer(points[0].index);
}

/* ========================
   VIEWER
======================== */
function openViewer(pointIndex) {
  const arrIdx = points.findIndex(p => p.index === pointIndex);
  if (arrIdx === -1) return;
  currentIdx = arrIdx;
  const p = points[currentIdx];

  document.querySelectorAll('.custom-marker').forEach(el => el.classList.remove('active'));
  markers[p.index].getElement().classList.add('active');
  
  document.getElementById('viewer-title').textContent = `Point #${p.index}`;
  document.getElementById('viewer-meta').textContent = `(${currentIdx + 1} / ${points.length})`;

  if (panoViewer) panoViewer.destroy();
  
  const imgUrl = imagesByIndex[p.index];
  if (imgUrl) {
    document.getElementById('empty-msg').style.display = 'none';
    document.getElementById('panorama').style.visibility = 'visible';
    
    panoViewer = pannellum.viewer('panorama', {
      type: 'equirectangular',
      panorama: imgUrl,
      autoLoad: true,
      showControls: false,
      yaw: 0
    });

    panoViewer.on('render', () => {
      const yaw = panoViewer.getYaw();
      document.getElementById('compass-rose').style.transform = `rotate(${-yaw}deg)`;
    });

    preloadNeighbors(currentIdx);
  } else {
    document.getElementById('panorama').style.visibility = 'hidden';
    document.getElementById('empty-msg').style.display = 'flex';
  }
  
  map.easeTo({ center: [p.lon, p.lat], duration: 400 });
}

/* ========================
   SMOOTHING FUNCTIONS
======================== */
function generateRedTrack() {
  const cpCount = 8; // Fixed to 8 control points
  
  // Clear existing
  clearControlPoints();
  clearRedTrack();
  
  // Generate control points from every Nth original point
  const step = Math.floor(points.length / (cpCount - 1));
  controlPoints = [];
  
  for (let i = 0; i < points.length; i += step) {
    const p = points[i];
    controlPoints.push([p.lon, p.lat]);
    if (controlPoints.length >= cpCount - 1) break;
  }
  
  // Always add the last point
  const lastP = points[points.length - 1];
  const lastCP = controlPoints[controlPoints.length - 1];
  if (!lastCP || lastCP[0] !== lastP.lon || lastCP[1] !== lastP.lat) {
    controlPoints.push([lastP.lon, lastP.lat]);
  }
  
  // Create control point markers
  controlPoints.forEach((cp, idx) => {
    const el = document.createElement('div');
    el.className = 'control-point-marker';
    
    const marker = new mapboxgl.Marker({ 
      element: el, 
      draggable: true 
    })
      .setLngLat(cp)
      .addTo(map);
    
    // Add click handler for removal
    el.onclick = (e) => {
      if (removeCPModeActive && controlPointMarkers.length > 3) {
        e.stopPropagation();
        const markerIdx = controlPointMarkers.indexOf(marker);
        if (markerIdx > -1) {
          marker.remove();
          controlPointMarkers.splice(markerIdx, 1);
          updateRedTrack();
          updateStatus();
        }
      }
    };
    
    marker.on('drag', () => updateRedTrack());
    marker.on('dragend', () => updateRedTrack());
    
    controlPointMarkers.push(marker);
  });
  
  updateRedTrack();
  document.getElementById('showRedTrack').checked = true;
  updateStatus();
  
  // Enable project button
  document.getElementById('projectPointsBtn').disabled = false;
}

function updateRedTrack() {
  // Update controlPoints array from marker positions
  controlPoints = controlPointMarkers.map(m => {
    const lngLat = m.getLngLat();
    return [lngLat.lng, lngLat.lat];
  });
  
  // Generate smooth curve
  const smoothCurve = generateCatmullRomCurve(controlPoints, 30);
  
  // Update map layer
  if (map.getLayer('red-track')) map.removeLayer('red-track');
  if (map.getSource('red-track')) map.removeSource('red-track');
  
  map.addSource('red-track', {
    type: 'geojson',
    data: {
      type: 'Feature',
      geometry: {
        type: 'LineString',
        coordinates: smoothCurve
      }
    }
  });
  
  map.addLayer({
    id: 'red-track',
    type: 'line',
    source: 'red-track',
    paint: {
      'line-color': '#ff4444',
      'line-width': 3,
      'line-opacity': 0.8
    }
  });
  
  redTrackLine = turf.lineString(smoothCurve);
  updateTrackVisibility();
}

function clearControlPoints() {
  controlPointMarkers.forEach(m => m.remove());
  controlPointMarkers = [];
  controlPoints = [];
}

function clearRedTrack() {
  if (map.getLayer('red-track')) map.removeLayer('red-track');
  if (map.getSource('red-track')) map.removeSource('red-track');
  redTrackLine = null;
}

/* ========================
   POINT PROJECTION
======================== */
function projectPointsToRed() {
  if (!redTrackLine) return;
  
  console.log('Starting projection...');
  
  // Calculate total length of blue track
  const blueTrack = turf.lineString(points.map(p => [p.lon, p.lat]));
  const blueTotalLength = turf.length(blueTrack, {units: 'kilometers'});
  
  // Calculate total length of red track
  const redTotalLength = turf.length(redTrackLine, {units: 'kilometers'});
  
  console.log('Blue length:', blueTotalLength, 'Red length:', redTotalLength);
  
  projectedPoints = [];
  
  let cumulativeBlueDistance = 0;
  
  points.forEach((p, idx) => {
    // Calculate distance along blue track for this point
    if (idx > 0) {
      const prevP = points[idx - 1];
      const segment = turf.lineString([[prevP.lon, prevP.lat], [p.lon, p.lat]]);
      const segmentLength = turf.length(segment, {units: 'kilometers'});
      cumulativeBlueDistance += segmentLength;
    }
    
    // Calculate percentage along blue track
    const percentage = blueTotalLength > 0 ? cumulativeBlueDistance / blueTotalLength : 0;
    
    // Find corresponding position on red track
    const redDistance = percentage * redTotalLength;
    const pointOnRed = turf.along(redTrackLine, redDistance, {units: 'kilometers'});
    
    projectedPoints.push({
      ...p,
      lon: pointOnRed.geometry.coordinates[0],
      lat: pointOnRed.geometry.coordinates[1],
      projected: true,
      redDistance: redDistance
    });
  });
  
  console.log('Projected', projectedPoints.length, 'points');
  
  // Update marker positions
  projectedPoints.forEach(p => {
    if (markers[p.index]) {
      markers[p.index].setLngLat([p.lon, p.lat]);
      markers[p.index].getElement().classList.add('projected');
    }
  });
  
  updateStatus();
  document.getElementById('exportBtn').disabled = false;
  document.getElementById('dragMode').disabled = false;
}

/* ========================
   DRAG MODE
======================== */
function enableDragMode() {
  if (!redTrackLine || projectedPoints.length === 0) return;
  
  dragModeActive = true;
  const redTotalLength = turf.length(redTrackLine, {units: 'kilometers'});
  
  projectedPoints.forEach((p, idx) => {
    const marker = markers[p.index];
    if (!marker) return;
    
    const el = marker.getElement();
    el.style.cursor = 'move';
    
    marker.setDraggable(true);
    
    marker.on('drag', () => {
      const lngLat = marker.getLngLat();
      const point = turf.point([lngLat.lng, lngLat.lat]);
      const snapped = turf.nearestPointOnLine(redTrackLine, point);
      
      // Get distance along red track
      let snapDistance = snapped.properties.location;
      
      // Apply constraints - can't pass neighbors
      const prevIdx = idx - 1;
      const nextIdx = idx + 1;
      
      if (prevIdx >= 0) {
        const prevDistance = projectedPoints[prevIdx].redDistance;
        if (snapDistance < prevDistance) {
          snapDistance = prevDistance;
        }
      }
      
      if (nextIdx < projectedPoints.length) {
        const nextDistance = projectedPoints[nextIdx].redDistance;
        if (snapDistance > nextDistance) {
          snapDistance = nextDistance;
        }
      }
      
      // Get point at constrained distance
      const constrainedPoint = turf.along(redTrackLine, snapDistance, {units: 'kilometers'});
      const constrainedCoord = constrainedPoint.geometry.coordinates;
      
      marker.setLngLat(constrainedCoord);
      projectedPoints[idx].lon = constrainedCoord[0];
      projectedPoints[idx].lat = constrainedCoord[1];
      projectedPoints[idx].redDistance = snapDistance;
    });
  });
}

function disableDragMode() {
  dragModeActive = false;
  
  projectedPoints.forEach(p => {
    const marker = markers[p.index];
    if (!marker) return;
    
    marker.setDraggable(false);
    marker.getElement().style.cursor = 'pointer';
  });
}

/* ========================
   EXPORT
======================== */
function exportJSON() {
  if (projectedPoints.length === 0) return;
  
  const exportData = {
    points: projectedPoints.map(p => ({
      index: p.index,
      lat: p.lat,
      lon: p.lon
    }))
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `smoothed_trip_${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

/* ========================
   UI HELPERS
======================== */
function updateMarkerColors() {
  points.forEach(p => {
    const el = markers[p.index]?.getElement();
    if (!el) return;
    if (el.classList.contains('projected')) return;
    el.style.backgroundColor = imagesByIndex[p.index] ? '#26a269' : '#2b6df6';
  });
}

function updateStatus() {
  document.getElementById('blueCount').textContent = points.length;
  document.getElementById('cpCount').textContent = controlPointMarkers.length;
  document.getElementById('projectedCount').textContent = projectedPoints.length;
}

function updateTrackVisibility() {
  const showBlue = document.getElementById('showBlueTrack').checked;
  const showRed = document.getElementById('showRedTrack').checked;
  
  map.setLayoutProperty('track', 'visibility', showBlue ? 'visible' : 'none');
  if (map.getLayer('red-track')) {
    map.setLayoutProperty('red-track', 'visibility', showRed ? 'visible' : 'none');
  }
}

function updateDotsVisibility() {
  const show = document.getElementById('showBlueDots').checked;
  Object.values(markers).forEach(m => {
    const el = m.getElement();
    el.style.display = show ? 'block' : 'none';
  });
}

function updateControlPointsVisibility() {
  const show = document.getElementById('showControlPoints').checked;
  controlPointMarkers.forEach(m => {
    const el = m.getElement();
    el.style.display = show ? 'block' : 'none';
  });
}

function fitToTrack() {
  if (!points.length) return;
  const b = new mapboxgl.LngLatBounds();
  points.forEach(p => b.extend([p.lon, p.lat]));
  map.fitBounds(b, { padding: 50 });
}

function navigate(dir) {
  if (!points.length) return;
  let next = (currentIdx + dir + points.length) % points.length;
  openViewer(points[next].index);
}

/* ========================
   MAP CLICK FOR CP INSERT
======================== */
map.on('click', (e) => {
  if (!addCPModeActive || !redTrackLine) return;
  
  const clickPoint = turf.point([e.lngLat.lng, e.lngLat.lat]);
  const snapped = turf.nearestPointOnLine(redTrackLine, clickPoint);
  const snapCoord = snapped.geometry.coordinates;
  
  // Find insertion index based on distance along line
  const snapDistance = snapped.properties.location;
  let insertIdx = 0;
  
  for (let i = 0; i < controlPoints.length - 1; i++) {
    const cpPoint = turf.point(controlPoints[i]);
    const cpSnap = turf.nearestPointOnLine(redTrackLine, cpPoint);
    if (cpSnap.properties.location > snapDistance) break;
    insertIdx = i + 1;
  }
  
  // Insert control point
  const el = document.createElement('div');
  el.className = 'control-point-marker';
  
  const marker = new mapboxgl.Marker({ 
    element: el, 
    draggable: true 
  })
    .setLngLat(snapCoord)
    .addTo(map);
  
  // Add click handler for removal
  el.onclick = (e) => {
    if (removeCPModeActive && controlPointMarkers.length > 3) {
      e.stopPropagation();
      const markerIdx = controlPointMarkers.indexOf(marker);
      if (markerIdx > -1) {
        marker.remove();
        controlPointMarkers.splice(markerIdx, 1);
        updateRedTrack();
        updateStatus();
      }
    }
  };
  
  marker.on('drag', () => updateRedTrack());
  marker.on('dragend', () => updateRedTrack());
  
  controlPointMarkers.splice(insertIdx, 0, marker);
  updateRedTrack();
  updateStatus();
});

/* ========================
   EVENT LISTENERS
======================== */
document.getElementById('generateRedBtn').onclick = generateRedTrack;
document.getElementById('projectPointsBtn').onclick = projectPointsToRed;
document.getElementById('exportBtn').onclick = exportJSON;

document.getElementById('showBlueDots').onchange = updateDotsVisibility;
document.getElementById('showBlueTrack').onchange = updateTrackVisibility;
document.getElementById('showRedTrack').onchange = updateTrackVisibility;

document.getElementById('addCPMode').onchange = (e) => {
  addCPModeActive = e.target.checked;
  if (addCPModeActive && removeCPModeActive) {
    document.getElementById('removeCPMode').checked = false;
    removeCPModeActive = false;
  }
  map.getCanvas().style.cursor = addCPModeActive ? 'crosshair' : '';
};

document.getElementById('removeCPMode').onchange = (e) => {
  removeCPModeActive = e.target.checked;
  if (removeCPModeActive && addCPModeActive) {
    document.getElementById('addCPMode').checked = false;
    addCPModeActive = false;
    map.getCanvas().style.cursor = '';
  }
  // Update cursor for control points
  controlPointMarkers.forEach(m => {
    m.getElement().style.cursor = removeCPModeActive ? 'pointer' : 'move';
  });
};

document.getElementById('showControlPoints').onchange = updateControlPointsVisibility;

document.getElementById('dragMode').onchange = (e) => {
  if (e.target.checked) {
    enableDragMode();
  } else {
    disableDragMode();
  }
};

document.getElementById('jsonInput').onchange = async (ev) => {
  const f = ev.target.files[0];
  if (f) processPoints(JSON.parse(await f.text()).points);
};

document.getElementById('imagesInput').onchange = (ev) => {
  Array.from(ev.target.files).forEach(f => {
    const m = f.name.match(/\d+/);
    if (m) imagesByIndex[parseInt(m[0])] = URL.createObjectURL(f);
  });
  updateMarkerColors();
};

document.getElementById('fitBtn').onclick = fitToTrack;

document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT') return;
  const k = e.key.toLowerCase();
  if (k === 'n') navigate(1);
  if (k === 'm') navigate(-1);
}, true);

/* ========================
   INIT
======================== */ 
loadDefaultData();

</script>
</body>
</html>